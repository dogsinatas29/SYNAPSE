순서도 로직 수정 작업ㅡv0.2.14fix

​단순히 위에서 아래로 내리는 게 중요한 게 아니라, **"어떤 놈들을 옆으로 나란히 세울 것인가"**를 결정하는 게 세로형 순서도의 핵심이야.
​1. 병렬 연결의 전제 조건: "동일한 부모, 동일한 위상"
​네가 만든 '나이 출력 프로그램'을 예로 들어보자.
​병렬이 되어야 하는 경우: 만 나이 출력 노드와 일반 나이 출력 노드. 이 둘은 '출력 방식 선택'이라는 동일한 부모 노드에서 갈라져 나왔고, 논리적으로 **동일한 위상(Step)**에 있지? 이런 놈들만 수평으로 배치되어야 해.
​병렬이 되면 안 되는 경우: 생일 입력 노드와 나이 계산 노드. 이 둘은 선후 관계가 명확하잖아? 이런 놈들이 옆으로 누워버리면 그게 바로 네가 본 '지구본'이 되는 거다.
​2. '레벨(Rank)'이 '중력'을 결정한다
​순서도 모드에서 노드의 좌표를 결정할 때 가장 우선시해야 할 원칙은 이거다:
​수직 거리(Y): 노드 간의 **논리적 선후 관계(Dependency)**가 하나라도 있다면, 무조건 층을 나눠라.
​수평 거리(X): 논리적 의존성이 없는 놈들(병렬 노드)끼리만 같은 층(Level) 안에서 좌우로 벌려라.

​3. 왜 이게 중요한가? (Cognitive Load)
​사람의 뇌는 위에서 아래로 흐르는 선을 볼 때 **"시간의 흐름"**이나 **"인과 관계"**로 인식해. 반면 옆으로 나란히 있는 노드들을 볼 때는 **"선택지"**나 **"동시 실행"**으로 인식하지.
지금 네 시냅스는 이 '뇌의 규칙'을 무시하고 아무나 옆에 세워두니까, 네 뇌가 "이게 왜 옆에 있지? 얘네가 동시에 일어나는 건가?"라며 과부하가 걸리는 거야.
​
​네가 구현할 로직에 이 필터를 끼워 넣어라:
​Dependency Check: 노드 A와 B 사이에 경로(Path)가 존재하는가?
​Yes: 경로가 있다면 무조건 Level(B) = Level(A) + 1 (세로 배치).
​No: 경로가 없고 부모가 같다면 Level(B) = Level(A) (수평 병렬 배치).

​1. 0.2.14 Hotfix: '지구본' 파괴 전략
​지금 가로로 퍼지는 현상을 잡기 위해 당장 코드에 박아야 할 3단계 긴급 처방이다.
​Step 1. 노드 랭킹 (Leveling): 모든 노드에 rank 속성을 부여해라. 진입 차수(In-degree)가 0인 놈이 rank 0. 그놈과 연결된 다음 놈들은 무조건 rank 1. 이렇게 구문적 순서대로 등급을 매겨.
​Step 2. Y축 좌표 강제 점유: 기존의 랜덤 좌표나 힘 지향(Force-directed) 좌표 계산을 중단시키고, node.y = node.rank * Vertical_Interval로 고정해버려.
​Step 3. X축 밸런싱: 같은 rank를 가진 노드들끼리만 모아서 X축으로 나열해. 이때, 부모 노드의 X 좌표를 기준으로 좌우로 펼쳐지게 만들면 부채꼴이 아니라 깔끔한 트리 구조가 된다.
​2. 구문 판단 로직의 이식
​네가 만든 '나이 계산 파이썬 프로그램'을 시냅스에 넣었을 때, 다음 순서로 노드가 찍혀야 한다.
​Level 0: Start / DB Connect
​Level 1: Input Name
​Level 2: Input Birth Data (Y, M, D)
​Level 3: Choice: International Age or Korean Age? (여기서만 X축 분기!)
​Level 4: Calculation Logic
​Level 5: Output & DB Save
​지금 0.2.14는 이 1~6번을 전부 한 평면에 쏟아놓고 "자, 이제 서로 밀어내!"라고 하고 있으니 지구본이 되는 거다.

​열심히 특정 로직 분석하려고 줌 당기고 좌표 맞춰놨는데, 파일 하나 새로 읽었다고 뷰포트가 (0, 0)으로 튕겨버리면 그 흐름이 다 깨지거든. 20년 차 시니어 엔지니어 입장에서 이건 **'컨텍스트 유지(Context Preservation)'**의 실패다.
​0.2.14 픽스에서 이 '뷰포트 고정(State Persistence)' 로직을 반드시 박아넣어야 해. 설계도를 다시 그려주마.
​1. 왜 튕기는가? (원인 분석)
​보통 캔버스 라이브러리들은 데이터(nodes, edges)가 업데이트되면 "새로운 세상이 열렸다"고 착각해서 fitView()나 초기 좌표 리셋 함수를 자동으로 때려버려. 네가 부트스트랩으로 .md 파일을 새로 집어넣을 때마다 이 초기화 로직이 트리거되는 거지.
​2. 해결책: '뷰포트 메모리' 시스템 구축
​데이터가 바뀌어도 사용자의 시선(Coordinate, Zoom level)은 유지되어야 한다.
​State Capture: 데이터를 갱신하기 직전, 현재의 x, y, zoom 값을 변수에 저장해라.
​Manual Re-apply: 새 노드들이 렌더링된 직후, fitView 같은 자동 함수를 막고 저장해둔 값을 강제로 다시 먹여야 한다.
​조건부 초기화: 사용자가 명시적으로 '새 프로젝트'를 열 때만 리셋하고, 기존 프로젝트 내에서 .md를 수정하거나 추가할 때는 **현재 시점을 고정(Lock)**하는 로직이 필요해.
​3. v0.2.14 픽스: "시선의 일관성"
​이게 해결되어야 네가 만든 그 '지구본' 로직에서 특정 클러스터를 뜯어보다가 코드를 고쳐도, 다시 그 자리로 돌아올 수 있어.
​좌표 고정: Transform 객체를 로컬 스토리지나 상태 관리(State)에 박아둬.
​줌 고정: 휠 조작으로 맞춰둔 배율을 전역 변수로 유지해.
​부트스트랩 예외 처리: 파일 로딩 후 렌더링 콜백 함수에서 setViewport(savedTransform)를 호출하게 만들어라.