v0.2.21
서버 클라이언트 구조로 팀장의 탑다운식 작업하달 및 공유, 그리고 머지를 시냅스 안에서 처리한다
팀장은 전체 로직을 완성하고 각 팀원들은 시냅스를 통해 접속한다음 팀장이 작업자의 작업 내용을 하나의 단위 ㅡ 허브 ㅡ로 묶어서 작업자를 각 허브당 지정하고 작업자에게 전송하면 rclone으로 폴더와 파일, 그리고 노드 구조가 팀원에게 전송된다.
각 팀원은 자신이 할당받은 허브를 규약.md파일에 의거해 작업하고 서버에 접속하면 팀장의 시냅스 화면에 작업자들의 허브가 동시에 뜨게된다. 규약.md에 의해 자동으로 엣지가 연결되고 팀장이 로직테스트를 하면 결과가 나온다
팀장이 이 내용을 승인하고 머지 누르면 팀장의 프로젝트폴더로 작업자들의 작업 결과물이 전송된다. 나중에 개별 승인도 가능하게 만들자
​🛰️ v0.2.21: Sovereign Protocol - 통합 설계 명세
​1. 시스템 개요 (System Overview)
​구조: 서버(팀장) - 클라이언트(작업자) 중앙 집중형 구조.
​철학: Top-Down Authority. 설계는 독점하되 구현은 분산하며, 모든 통합은 팀장의 시냅스(SYNAPSE) 내에서 이루어진다.
​핵심 도구: * SYNAPSE: 시각화, 권한 할당, 논리 검증 및 머지 컨트롤러.
​rclone: 필터링 기반의 정밀 파일 배송 및 수집 엔진.
​규약.md: 프로젝트의 유일 법전(함수, 경로, 인터페이스 정의).
​2. 작업 하달 및 전송 (Distribution Phase)
​Hub Allocation: 팀장이 시냅스에서 노드 뭉치를 '허브(Hub)' 단위로 묶고 주작업자를 지정한다.
​rclone 필터 배송: 허브 정보가 결정되면 서버는 filters.txt를 동적 생성하여 rclone으로 다음을 전송한다.
​아키텍처.md (해당 허브의 슬라이싱된 구조 정보)
​규약.md (공통 함수 및 폴더 트리 규약)
​해당 허브 작업에 필요한 소스 파일 및 Rules.md (Read-only).
​3. 작업 및 동시 접속 (Working & Live Session)
​Autonomous Logic: 작업자는 GEMINI.md에 링크된 규약.md를 준수하며 허브 내부 로직을 완성한다.
​Live Buffering: 작업자가 서버에 접속(로그인)하면, 서버의 시냅스 화면에는 각 작업자의 허브가 '임시 버퍼' 상태로 실시간 렌더링된다.
​Auto-Edge Binding: 규약.md에 정의된 입출력 인터페이스에 따라, 팀장의 마스터 노드와 작업자의 허브 노드가 자동으로 엣지(Edge)로 연결된다.
​4. 로직 테스트 및 승인 (Validation & Merge)
​Integrated Testing: 팀장은 자신의 화면에 뜬 모든 작업자의 허브를 포함하여 전체 로직 테스트를 수행한다.
​Merge & Commit: * 일괄/개별 승인: 팀장이 시냅스에서 머지(Merge) 버튼을 누른다.
​Physical Write: rclone이 작업자의 임시 폴더에서 서버의 정식 프로젝트 폴더로 결과물을 이동(rclone move)시킨다.
​Architecture Promotion: 버퍼에 있던 노드 정보가 마스터 아키텍처.md에 정식으로 기입된다.
​📜 규약.md 필수 포함 조항 (Draft)
​[Function]: 모든 공통 함수는 SY_ 또는 VG_ 접두사를 사용한다.
​[Interface]: 허브 간 연결은 규약에 명시된 Portal_Node를 통해서만 이루어진다.
​[Path]: 작업자의 결과물은 /src/workers/[Worker_ID]/ 폴더로 우선 업로드된다.
​[Naming]: 파일명은 [Hub_ID]_[Function_Name].ts 형식을 준수한다.

​🛰️ v0.2.21: Sovereign Protocol - 개괄 (Overview)
​1. 아키텍처 구조: 분산형 자치 허브
​팀장(Master): 전체 청사진과 규약.md를 독점. 아키텍처.md를 통해 모든 허브와 작업자 점유 상태를 통제.
​작업자(Worker): 할당받은 **허브(Hub)**라는 샌드박스 내에서만 논리 구성.
​버퍼 시스템: 작업자의 결과물은 temp_architecture.md라는 임시 버퍼에 먼저 기록되어 팀장의 검수를 대기함.
​2. 규약 및 파일 체인 (Constitution & Chain)
​규약.md: 공통 함수 API, 파일/폴더 트리, 전송 규약이 담긴 유일한 법전.
​GEMINI.md: 규약.md를 강제 참조(Link)하여 LLM의 환각을 방지하고 작업 범위를 제한.
​Rules.md: 시냅스의 물리 법칙(중력 등). 작업자에게는 Read-Only로만 배포되어 시각적 파편화 방지.
​3. rclone 기반 배송 및 머지 로직
​배포 (Login): rclone 필터링(filters.txt)을 통해 작업자 ID에 맞는 허브 조각과 필수 규약 파일만 선별 전송.
​회수 (Logout): 작업 완료 후 결과물을 서버의 /buffer/[Worker_ID] 폴더로 업로드.
​병합 (Merge): 팀장이 시냅스에서 Merge 버튼을 클릭하면, rclone이 임시 파일을 정식 소스 폴더로 이동(rclone move)시키고 아키텍처를 마스터로 승격.
​4. 연속성 및 테스트
​Git Zero: 브랜치 관리 없이 '버퍼-승인' 구조만으로 작업의 연속성 확보.
​환경 복제: 규약.md가 모든 환경을 통제하므로, 서버와 클라이언트 어디서든 동일한 로직 테스트 결과 보장.

​🏗️ 아키텍처.md: 논리 구조 및 권한 지도 설계
​1. 계층적 데이터 구조 (Hierarchy)
​이 파일은 다음의 3단계 위계를 명확히 구분해야 하네.
​Layer 1: Hub (The Territory) * 가장 큰 논리 단위. 특정 작업자(예: Gemini)에게 할당된 '자치 구역'.
​속성: Hub_ID, Owner_ID, Status(Locked/Open), Last_Sync.
​Layer 2: Cluster (The Module)
​허브 내부의 기능적 뭉치.
​속성: Cluster_ID, Parent_Hub, Logic_Type(Sequential/Parallel).
​Layer 3: Node (The Atom)
​실제 연산 단위.
​속성: Node_ID, Function_Tag(from 규약.md), Position(Gravity-based).
​2. 작업자 정보의 동적 매핑 (Worker Metadata)
​아키텍처.md 내에 사용자 정보가 들어감으로써 발생하는 강력한 효과는 **'접근 제어(Access Control)'**네.
​Owner-Only Write: 제미나이가 로그인해서 아키텍처.md를 읽을 때, 자신의 Owner_ID와 일치하지 않는 허브 구역은 수정할 수 없도록 **물리적/논리적 락(Lock)**을 거는 기준점이 되네.
​Traceability: 나중에 병합 과정에서 특정 노드가 꼬였을 때, 아키텍처.md만 보면 "이건 Gemini가 담당하던 구역의 노드군"이라고 즉시 범인을 찾을 수 있지.
​3. 시냅스(SYNAPSE) 연동 로직
​이 파일의 내용을 바탕으로 시냅스 툴은 화면을 이렇게 그려야 하네.
​영역 표시: 각 허브 영역을 작업자별 테마 색상(예: Gemini는 파란색, Claude는 보라색)으로 묶어서 시각화.
​상태 표시: 작업 중인 허브는 밝게 빛나고, 예약된 허브는 반투명하게 처리.
​중력 격리: 허브 내부의 노드들은 자기 허브의 중력 중심에 묶이되, 허브와 허브 사이는 규약.md에서 정의한 '접점 노드'로만 연결.

## [HUB: HUB_001]
- OWNER: Gemini
- STATUS: Active
- CONSTITUTION_REF: 규약.md

### [CLUSTER: CL_FILE_WATCHER]
- NODES: [N001, N002, N003]
- GRAVITY_CENTER: {x: 100, y: -200}

#### [NODE: N001]
- TAG: VG_SCAN_DIR
- POS: {x: 105, y: -195}
- TARGET: N002


🚬 시니어의 피드백
​이 구조라면 자네가 팀장으로서 아키텍처.md 파일 하나만 열어봐도 "누가 어디서 뭘 하는지" 한눈에 보이겠구먼. 특히 허브에 사용자 정보를 박아넣은 건 **'서버-클라이언트 구조'**로 갈 때 가장 완벽한 식별자가 될 걸세.
​인천의 새벽 3시 10분, 이제 이 모든 정보가 담길 아키텍처.md의 최종 규격을 확정 지어보세.
​선택 1: 허브와 노드 간의 부모-자식 관계를 정의하는 데이터 필드 설계.
​선택 2: 아키텍처.md를 파싱해서 시냅스에 뿌려줄 '허브 렌더러' 로직 설계.
​선택 3: 작업자 로그인 시 해당 구역만 떼어내 주는 '슬라이싱 스크립트' 설계.

​📑 The Sovereign Configuration: GEMINI & 규약.md
​1. GEMINI.md: 제미나이의 '정신적 지주'
​이 파일은 제미나이가 작업할 때마다 가장 먼저 읽어 들여야 할 **'시스템 프롬프트의 확장판'**이네.
​프로그램 4대 원칙: (코딩 전 사고, 단순성 우선, 최소 수정, 목표 중심) -> 논리의 필터
​청사진 & 설계도: 전체 시스템의 최종 진화 형태 -> 목표 지점
​마일스톤 링크: 현재 우리가 서 있는 위치 -> 현재 좌표
​[NEW] 규약(가칭).md 링크: "여기 정의된 함수명만 써라" -> 행동 강령
​2. 규약.md: 작업의 '기술적 인터페이스'
​자네가 정하기 나름이라 했지만, 자동화를 위해서는 최소한 이 3가지 섹션은 포함되어야 하네.
​[Section 1: Global Function Registry]
​모든 작업자가 공유하는 표준 함수명 리스트.
​예: SY_RENDER_NODE, VG_EXEC_RCLONE
​제미나이는 여기 없는 함수를 독자적으로 생성할 수 없음.
​[Section 2: Worker Allocation (Hub Ownership)]
​Hub_01: Worker_Gemini (Status: In-Progress)
​Hub_02: Worker_Claude (Status: Reserved)
​제미나이는 자기가 맡은 허브 외의 구역은 'ReadOnly'로만 참조함.
​[Section 3: Naming & Logic Rules]
​변수명, 주석 규칙, 에러 처리 방식 등.



​🚀 Milestone v0.2.21 - Sovereign Distributed Architecture
​📅 작업 정보
​상태: 🏗️ Planned / 🚧 In-Progress
​관련 마일스톤: v0.2.20 (Legacy Logic Cleanup)
​목표: 서버-클라이언트 구조에서 규약.md를 기반으로 한 독재적 효율성 및 논리 연속성 확보

로그인 시나리오
이제 로그인 시나리오를 생각해보자
로그인하면 아키텍처.md를 자동으로 인식하고 이 정보를 바탕으로 임시 아키텍처.md 파일이 생성된다. 팀장의 아키텍처.md파일을기반으로 해서 작업자의 아키텍처가 로드는 되지만 임시로 이파일에 버퍼처럼 기록될뿐이다.  여기서 팀장이 확정하면 이건 임시가 아니라 정식 아키텍처.md로 write된다. 이때 팀장의 화면에는 작업자의 로그인 여부에 따라 작업자가 할당받은 허브 정보가 숨김처리된다. 안그러면 중복 표시 될테니까. 서버 열면 그냥 버퍼로 쓰일 아키텍처.md가 쓰인다는 말이야. 

팀장이 ok하면 이제 작업자의 정보가 팀장의 아키텍처.md에 편입된다. 그리고 작업자의 프로그래밍 결과물이 팀장의 프로젝트 폴더로 업로드 된다.
그말은 규약.md 파일에 폴더구조와 파일명도 들어있어야한다는 말이야
​🧠 상세 설계 및 로직
​1. 서버-클라이언트 및 버퍼 구조 (Server-Client Buffer)
​Centralized Command: 팀장(서버)은 마스터 아키텍처.md를 독점하며, 작업자(클라이언트)는 로그인 시 자기 몫의 허브(Hub) 정보만 슬라이싱하여 내려받음.
​Staging Buffer: 작업자의 결과물은 즉시 마스터에 반영되지 않고, 서버의 temp_architecture.md(버퍼)에 기록됨. 팀장의 승인(Merge) 전까지 마스터 데이터는 신성불가침 영역으로 유지.
​Visual Isolation: 작업자가 로그인한 구역은 팀장의 화면에서 숨김 처리되어 중복 렌더링 및 편집 충돌을 원천 차단.
​2. 규약 기반 통제 (Constitution-Based Governance)
​규약.md: 프로젝트의 법전. 공통 함수 레지스트리(API), 작업자별 허브 오너십, 파일/폴더 경로 규약을 포함.
​GEMINI.md 체인: 작업자 LLM은 실행 시 GEMINI.md를 로드하며, 이 문서에 링크된 규약.md를 강제 참조함. 규약에 없는 함수 생성은 린터(Linter)에 의해 즉시 반려.
​Logical Atomicity: 작업자는 허브라는 샌드박스 안에서 자율적으로 논리를 구성하되, 허브의 입출력 규격은 반드시 규약에 정의된 인터페이스를 준수.
​3. rclone 기반 머지 프로세스 (rclone Sync & Merge)
​Login Sync: rclone copy를 통해 서버의 마스터 청사진과 규약을 클라이언트로 동기화.
​Logout Upload: 작업 종료 시 rclone copy를 통해 클라이언트의 결과물을 서버의 임시 버퍼 폴더로 업로드.
​Final Merge: 팀장이 시냅스에서 머지 버튼 클릭 시, rclone으로 업로드된 파일들을 정식 소스 경로로 이동(rclone move)시키고 아키텍처를 마스터로 승격.
​🛠️ 기술적 변경 사항
​Architecture Update: 아키텍처.md에 Hub_ID, Owner_ID, Lock_Status 필드 추가.
​New Document: 규약.md 신설 (함수 레지스트리 및 폴더 트리 규약 명시).
​Sync Script: rclone을 이용한 로그인/로그아웃 자동 동기화 쉘 스크립트 작성.
​Synapse UI: 버퍼 상태의 노드를 검수하고 승인하는 'Merge' 버튼 및 고스트 노드 시각화 기능 추가.
​⚠️ 예외 처리 및 주의 사항
​rclone 충돌 방지: 업로드 시 파일명에 [Worker_ID] 프리픽스를 강제하여 마스터 파일 덮어쓰기 방지.
​버전 불일치: 규약.md 버전이 서버와 클라이언트 간에 다를 경우 로그인 차단.
​물리 법칙 고정: Rules.md(중력 상수 등)는 작업자가 수정할 수 없도록 Read-Only로 배포.
​📦 Hub-Specific Distribution & rclone Protocol
​1. 전송 파일 결정 (What to Send)
​허브 오너십이 결정되면, 서버는 해당 작업자에게 **'최소 필요 패키지'**를 구성해야 하네.
​공통 파일 (Common): 규약.md, Rules.md(Read-only), GEMINI.md.
​작업별 파일 (Specific): 아키텍처.md(해당 허브 구역만 슬라이싱된 조각), 해당 허브가 참조하는 기존 소스 코드 파일들.
​필터링 규칙: rclone의 --include나 --filter 옵션을 사용하여, 작업자가 건드리지 말아야 할 다른 허브의 소스는 전송 목록에서 원천 배제하네.
​2. 전송 시점 (When to Send)
​배포 (Distribute): 작업자가 로그인(Login)하여 세션을 활성화하는 순간.
​회수 (Collect): 작업자가 로그아웃(Logout) 버튼을 누르거나, 작업 완료(Complete) 신호를 보낼 때.
​동기화 (Sync): 팀장이 규약.md를 수정하여 전체 공지가 필요할 때 (서버 -> 전체 클라이언트 브로드캐스트).
​3. 전송 방법 (How to Send: rclone Command)
​자네 프로젝트의 폴더 구조와 연동된 rclone 전략이네.
구조: rclone copy [Source] [Destination] --filter-from filters.txt
필터링 전략 (filters.txt):
+ /규약.md
+ /Rules.md
+ /GEMINI.md
+ /src/hub_[Hub_ID]/**
- /** (나머지 모든 파일 제외)
로직: 서버는 작업자의 ID와 허브 ID를 매칭하여 이 필터 파일을 실시간으로 생성하고, rclone을 실행해 작업자의 로컬 버퍼 폴더로 쏴주네.
​[SECTION: TRANSPORT_PROTOCOL]
​Folder Structure: * /master: 팀장의 메인 저장소
​/buffer/[Worker_ID]: 작업자별 임시 업로드 공간
​/client_env: 작업자가 실제로 내려받아 작업할 로컬 경로
​Transfer Logic:
​Step 1: 서버가 아키텍처.md에서 해당 유저의 Hub_ID를 식별.
​Step 2: rclone이 해당 Hub와 연관된 파일들만 /master에서 추출하여 /client_env로 복사.
​Step 3: 작업 완료 시 클라이언트는 자신의 /client_env를 서버의 /buffer/[Worker_ID]로 전송.
​🚬 시니어의 피드백
​자네, rclone을 단순히 FTP처럼 쓰는 게 아니라 **'논리적 필터'**로 쓰겠다는 발상이 아주 좋아. 이렇게 하면 작업자 PC에는 전체 소스가 깔리지 않으니 보안도 좋고, 무엇보다 작업자가 헷갈릴 일이 없지. 자기가 작업할 것만 딱 보이니까.
​📅 v0.2.21 마일스톤 업데이트: 배송 시스템 확정
​자, 이제 이 전송 로직을 v0.2.21 문서에 한 줄 더 추가했네.
​추가 사항: rclone 필터링 규칙 기반의 '세션별 파일 패키징' 로직.