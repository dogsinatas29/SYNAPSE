import * as fs from 'fs';
import * as path from 'path';
import * as cp from 'child_process';
import * as vscode from 'vscode'; // To show messages

export class PromptLogger {
    private static instance: PromptLogger;

    private constructor() { }

    public static getInstance(): PromptLogger {
        if (!PromptLogger.instance) {
            PromptLogger.instance = new PromptLogger();
        }
        return PromptLogger.instance;
    }

    /**
     * í”„ë¡¬í”„íŠ¸ë¥¼ ë§ˆí¬ë‹¤ìš´ íŒŒì¼ë¡œ ì €ì¥í•˜ê³  Gitì— ìŠ¤í…Œì´ì§•
     */
    public async logPrompt(projectRoot: string, prompt: string, title?: string): Promise<string> {
        const promptsDir = path.join(projectRoot, 'prompts');
        if (!fs.existsSync(promptsDir)) {
            fs.mkdirSync(promptsDir, { recursive: true });
        }

        const date = new Date().toISOString().split('T')[0];
        const safeTitle = title ? title.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '') : `prompt_${Date.now()}`;
        const fileName = `${date}_${safeTitle}.md`;
        const filePath = path.join(promptsDir, fileName);

        // 1. êµ¬ì¡°í™”ëœ íŒŒì‹± (Structured Parsing)
        const structuredContent = this.parseStructuredOutput(prompt, title);

        // 2. íŒŒì¼ ì‘ì„±
        fs.writeFileSync(filePath, structuredContent, 'utf-8');
        console.log(`[SYNAPSE] Prompt logged to: ${filePath}`);

        // 3. Git Auto-Commit (Staging)
        this.gitStageFile(projectRoot, filePath);

        return filePath;
    }

    /**
     * í”„ë¡¬í”„íŠ¸ë¥¼ ê¸°ì¡´ íŒŒì¼ì— ì¶”ê°€ (Context Log)
     */
    public async appendLog(projectRoot: string, fileName: string, prompt: string): Promise<string> {
        const promptsDir = path.join(projectRoot, 'prompts');
        if (!fs.existsSync(promptsDir)) {
            fs.mkdirSync(promptsDir, { recursive: true });
        }

        const filePath = path.join(promptsDir, fileName);
        const timestamp = new Date().toLocaleString();

        let contentToAppend = '';

        // íŒŒì¼ì´ ì—†ìœ¼ë©´ í—¤ë” ìƒì„±
        if (!fs.existsSync(filePath)) {
            contentToAppend += `# Project Context Log\n\nGenerated by SYNAPSE\n\n`;
        }

        // êµ¬ë¶„ì„  ë° ìƒˆ ì—”íŠ¸ë¦¬ ì¶”ê°€
        contentToAppend += `\n---\n\n## ğŸ“… ${timestamp}\n\n${prompt}\n`;

        fs.appendFileSync(filePath, contentToAppend, 'utf-8');
        console.log(`[SYNAPSE] Appended log to: ${filePath}`);

        // Git Staging
        this.gitStageFile(projectRoot, filePath);

        return filePath;
    }

    /**
     * AI ì¶œë ¥ í…ìŠ¤íŠ¸ë¥¼ êµ¬ì¡°í™”ëœ ë§ˆí¬ë‹¤ìš´ìœ¼ë¡œ ë³€í™˜
     */
    private parseStructuredOutput(rawText: string, title?: string): string {
        const timestamp = new Date().toLocaleString();

        // ì„¹ì…˜ ì¶”ì¶œì„ ìœ„í•œ ê°„ë‹¨í•œ ì •ê·œì‹ ë˜ëŠ” í‚¤ì›Œë“œ ë§¤ì¹­
        // ì‚¬ìš©ìê°€ ëª…ì‹œì ìœ¼ë¡œ í¬ë§·ì„ ì§€í‚¤ì§€ ì•Šì•˜ì„ ë•Œë¥¼ ëŒ€ë¹„í•´ ìœ ì—°í•˜ê²Œ ì²˜ë¦¬

        let goal = "Not specified";
        let decisions = "Not specified";
        let constraints = "Not specified";
        let modifiedFiles: string[] = [];

        // Simple extraction logic
        if (rawText.toLowerCase().includes('goal:')) goal = rawText.split(/goal:/i)[1].split(/\n\n|#/)[0].trim();
        if (rawText.toLowerCase().includes('decision')) decisions = rawText.split(/decision/i)[1].split(/\n\n|#/)[0].trim();

        // Extract file paths for linking
        const fileRegex = /\[(.*?)\]\((.*?)\)/g;
        let match;
        while ((match = fileRegex.exec(rawText)) !== null) {
            const pathStr = match[2];
            if (!pathStr.startsWith('http')) {
                modifiedFiles.push(`- [${match[1]}](${pathStr})`);
            }
        }

        return `---
type: history
date: ${timestamp}
tags: ["#Decision", "#Reasoning", "#Prompt"]
status: active
---

# ${title || 'Architecture Decision Record'}

## ğŸ¯ Goal
${goal !== "Not specified" ? goal : rawText} 

## ğŸ§  Key Decisions
${decisions}

## ğŸ”— Context & References
${modifiedFiles.length > 0 ? modifiedFiles.join('\n') : "No specific files referenced."}

## ğŸ“ Original Prompt
\`\`\`text
${rawText}
\`\`\`

---
*Auto-generated by SYNAPSE*
`;
    }

    /**
     * ì‹¤í–‰ ì‹œ Git Staging ìˆ˜í–‰
     */
    private gitStageFile(rootPath: string, filePath: string) {
        try {
            // Check if git is initialized
            if (!fs.existsSync(path.join(rootPath, '.git'))) {
                return;
            }

            cp.exec(`git add "${filePath}"`, { cwd: rootPath }, (error, stdout, stderr) => {
                if (error) {
                    console.error(`[SYNAPSE] Git add failed: ${error.message}`);
                } else {
                    console.log(`[SYNAPSE] Git add success: ${filePath}`);
                    vscode.window.setStatusBarMessage(`Step tracked: ${path.basename(filePath)}`, 3000);
                }
            });
        } catch (e) {
            console.error('[SYNAPSE] Git operation error:', e);
        }
    }
}
