/**
 * SYNAPSE Canvas Engine
 * HTML5 Canvas 기반 노드 시각화 엔진
 */

class CanvasEngine {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');

        // 캔버스 크기 설정
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        // 변환 상태 (줌/팬)
        this.transform = {
            zoom: 1.0,
            offsetX: 0,
            offsetY: 0
        };

        // 데이터
        this.nodes = [];
        this.edges = [];
        this.selectedNode = null;

        // 인터랙션 상태
        this.isDragging = false;
        this.dragStart = { x: 0, y: 0 };

        // 이벤트 리스너 등록
        this.setupEventListeners();

        // 렌더링 루프 시작
        this.render();
    }

    resizeCanvas() {
        const container = this.canvas.parentElement;
        this.canvas.width = container.clientWidth;
        this.canvas.height = container.clientHeight;
    }

    setupEventListeners() {
        // 마우스 휠 (줌)
        this.canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            this.zoom(delta, e.offsetX, e.offsetY);
        });

        // 마우스 드래그 (팬)
        this.canvas.addEventListener('mousedown', (e) => {
            this.isDragging = true;
            this.dragStart = { x: e.offsetX, y: e.offsetY };
        });

        this.canvas.addEventListener('mousemove', (e) => {
            if (this.isDragging) {
                const dx = e.offsetX - this.dragStart.x;
                const dy = e.offsetY - this.dragStart.y;
                this.pan(dx, dy);
                this.dragStart = { x: e.offsetX, y: e.offsetY };
            }
        });

        this.canvas.addEventListener('mouseup', () => {
            this.isDragging = false;
        });

        this.canvas.addEventListener('mouseleave', () => {
            this.isDragging = false;
        });

        // 노드 클릭
        this.canvas.addEventListener('click', (e) => {
            const worldPos = this.screenToWorld(e.offsetX, e.offsetY);
            const clickedNode = this.getNodeAt(worldPos.x, worldPos.y);

            if (clickedNode) {
                this.selectedNode = clickedNode;
                console.log('Selected node:', clickedNode);
            } else {
                this.selectedNode = null;
            }
        });
    }

    zoom(delta, centerX, centerY) {
        const oldZoom = this.transform.zoom;
        this.transform.zoom *= delta;
        this.transform.zoom = Math.max(0.1, Math.min(5.0, this.transform.zoom));

        // 줌 중심점 조정
        const zoomRatio = this.transform.zoom / oldZoom;
        this.transform.offsetX = centerX - (centerX - this.transform.offsetX) * zoomRatio;
        this.transform.offsetY = centerY - (centerY - this.transform.offsetY) * zoomRatio;

        this.updateZoomDisplay();
    }

    pan(dx, dy) {
        this.transform.offsetX += dx;
        this.transform.offsetY += dy;
    }

    screenToWorld(screenX, screenY) {
        return {
            x: (screenX - this.transform.offsetX) / this.transform.zoom,
            y: (screenY - this.transform.offsetY) / this.transform.zoom
        };
    }

    worldToScreen(worldX, worldY) {
        return {
            x: worldX * this.transform.zoom + this.transform.offsetX,
            y: worldY * this.transform.zoom + this.transform.offsetY
        };
    }

    getNodeAt(worldX, worldY) {
        for (const node of this.nodes) {
            const nodeWidth = 120;
            const nodeHeight = 60;

            if (worldX >= node.position.x && worldX <= node.position.x + nodeWidth &&
                worldY >= node.position.y && worldY <= node.position.y + nodeHeight) {
                return node;
            }
        }
        return null;
    }

    loadProjectState(projectState) {
        this.nodes = projectState.nodes;
        this.edges = projectState.edges;

        // UI 업데이트
        document.getElementById('node-count').textContent = this.nodes.length;
        document.getElementById('edge-count').textContent = this.edges.length;

        // 로딩 숨기기
        document.getElementById('loading').style.display = 'none';

        // Fit view
        this.fitView();

        console.log('Loaded project state:', projectState);
    }

    fitView() {
        if (this.nodes.length === 0) return;

        // 모든 노드를 포함하는 바운딩 박스 계산
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;

        for (const node of this.nodes) {
            minX = Math.min(minX, node.position.x);
            minY = Math.min(minY, node.position.y);
            maxX = Math.max(maxX, node.position.x + 120);
            maxY = Math.max(maxY, node.position.y + 60);
        }

        const width = maxX - minX;
        const height = maxY - minY;

        // 캔버스에 맞게 줌 조정
        const zoomX = this.canvas.width / (width + 100);
        const zoomY = this.canvas.height / (height + 100);
        this.transform.zoom = Math.min(zoomX, zoomY, 1.0);

        // 중앙 정렬
        this.transform.offsetX = (this.canvas.width - width * this.transform.zoom) / 2 - minX * this.transform.zoom;
        this.transform.offsetY = (this.canvas.height - height * this.transform.zoom) / 2 - minY * this.transform.zoom;

        this.updateZoomDisplay();
    }

    updateZoomDisplay() {
        document.getElementById('zoom-level').textContent = Math.round(this.transform.zoom * 100) + '%';
    }

    render() {
        // 캔버스 클리어
        this.ctx.fillStyle = '#1e1e1e';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // 변환 적용
        this.ctx.save();
        this.ctx.translate(this.transform.offsetX, this.transform.offsetY);
        this.ctx.scale(this.transform.zoom, this.transform.zoom);

        // 그리드 그리기
        this.renderGrid();

        // 엣지 그리기
        for (const edge of this.edges) {
            this.renderEdge(edge);
        }

        // 노드 그리기
        for (const node of this.nodes) {
            this.renderNode(node);
        }

        this.ctx.restore();

        // 다음 프레임 요청
        requestAnimationFrame(() => this.render());
    }

    renderGrid() {
        const gridSize = 50;
        const startX = Math.floor(-this.transform.offsetX / this.transform.zoom / gridSize) * gridSize;
        const startY = Math.floor(-this.transform.offsetY / this.transform.zoom / gridSize) * gridSize;
        const endX = startX + this.canvas.width / this.transform.zoom + gridSize;
        const endY = startY + this.canvas.height / this.transform.zoom + gridSize;

        this.ctx.strokeStyle = '#282828';
        this.ctx.lineWidth = 1 / this.transform.zoom;

        for (let x = startX; x < endX; x += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, startY);
            this.ctx.lineTo(x, endY);
            this.ctx.stroke();
        }

        for (let y = startY; y < endY; y += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(startX, y);
            this.ctx.lineTo(endX, y);
            this.ctx.stroke();
        }
    }

    renderNode(node) {
        const x = node.position.x;
        const y = node.position.y;
        const width = 120;
        const height = 60;

        // 노드 배경
        this.ctx.fillStyle = node.visual.opacity < 1 ? 'rgba(60, 56, 54, 0.5)' : '#3c3836';
        this.ctx.fillRect(x, y, width, height);

        // 노드 테두리
        this.ctx.strokeStyle = node.data.color || '#b8bb26';
        this.ctx.lineWidth = 2 / this.transform.zoom;

        if (node.visual.dashArray) {
            this.ctx.setLineDash([5, 5]);
        } else {
            this.ctx.setLineDash([]);
        }

        if (this.selectedNode === node) {
            this.ctx.lineWidth = 3 / this.transform.zoom;
            this.ctx.strokeStyle = '#fabd2f';
        }

        this.ctx.strokeRect(x, y, width, height);
        this.ctx.setLineDash([]);

        // 노드 텍스트
        this.ctx.fillStyle = '#ebdbb2';
        this.ctx.font = `${12 / this.transform.zoom}px Inter, sans-serif`;
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(node.data.label, x + width / 2, y + height / 2);

        // 상태 표시
        if (node.status === 'proposed') {
            this.ctx.fillStyle = 'rgba(250, 189, 47, 0.2)';
            this.ctx.fillRect(x, y, width, height);
        }
    }

    renderEdge(edge) {
        const fromNode = this.nodes.find(n => n.id === edge.from);
        const toNode = this.nodes.find(n => n.id === edge.to);

        if (!fromNode || !toNode) return;

        const fromX = fromNode.position.x + 60;
        const fromY = fromNode.position.y + 30;
        const toX = toNode.position.x + 60;
        const toY = toNode.position.y + 30;

        this.ctx.strokeStyle = edge.visual.color;
        this.ctx.lineWidth = edge.visual.thickness / this.transform.zoom;

        if (edge.visual.style === 'dashed') {
            this.ctx.setLineDash([5, 5]);
        }

        this.ctx.beginPath();
        this.ctx.moveTo(fromX, fromY);

        // 곡선 화살표
        const cpX = (fromX + toX) / 2;
        const cpY = (fromY + toY) / 2 - 30;
        this.ctx.quadraticCurveTo(cpX, cpY, toX, toY);

        this.ctx.stroke();
        this.ctx.setLineDash([]);

        // 화살표 머리
        const angle = Math.atan2(toY - cpY, toX - cpX);
        const arrowSize = 10 / this.transform.zoom;

        this.ctx.beginPath();
        this.ctx.moveTo(toX, toY);
        this.ctx.lineTo(
            toX - arrowSize * Math.cos(angle - Math.PI / 6),
            toY - arrowSize * Math.sin(angle - Math.PI / 6)
        );
        this.ctx.lineTo(
            toX - arrowSize * Math.cos(angle + Math.PI / 6),
            toY - arrowSize * Math.sin(angle + Math.PI / 6)
        );
        this.ctx.closePath();
        this.ctx.fillStyle = edge.visual.color;
        this.ctx.fill();
    }
}

// 초기화
let engine;

window.addEventListener('DOMContentLoaded', async () => {
    engine = new CanvasEngine('canvas');

    // 프로젝트 상태 로드
    try {
        console.log('Loading project state from /data/project_state.json...');
        const response = await fetch('/data/project_state.json');
        console.log('Response status:', response.status, response.statusText);

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const projectState = await response.json();
        console.log('Project state loaded:', projectState);
        engine.loadProjectState(projectState);
    } catch (error) {
        console.error('Failed to load project state:', error);
        document.getElementById('loading').innerHTML = `
            <div>❌ Failed to load project</div>
            <div style="font-size: 12px; margin-top: 8px; color: #fb4934;">${error.message}</div>
            <div style="font-size: 11px; margin-top: 4px; color: #928374;">Check browser console (F12) for details</div>
        `;
    }

    // 툴바 버튼 이벤트
    document.getElementById('btn-fit').addEventListener('click', () => {
        engine.fitView();
    });

    document.getElementById('btn-reset').addEventListener('click', () => {
        engine.transform = { zoom: 1.0, offsetX: 0, offsetY: 0 };
        engine.updateZoomDisplay();
    });

    // 모드 전환 버튼
    document.querySelectorAll('[data-mode]').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('[data-mode]').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            document.getElementById('current-mode').textContent = btn.dataset.mode.charAt(0).toUpperCase() + btn.dataset.mode.slice(1);
        });
    });
});
